1) Нельзя передавать generic примитивные типы в качестве параметра:
   MyPriorityQueue<int> intQueue = new MyPriorityQueue<int>();.--MyPriorityQueue<Integer> intQueue = new MyPriorityQueue<Integer>();>
2) Зачем inner-класс MyPriorityQueue называть ListElement? Корректнее так:
   ListElement --> QueueElement
3) В методе dequeue() незачем бросать RuntimeException. Скорее всего подразумевалось так:
   throw new RuntimeException("Queue is empty!!!") --> throw new EmptyQueueException("Queue is empty!!!")
4) Не вижу смысла в методах класса QueueElement, т.к. он inner-класс MyPriorityQueue и его поля и так доступны.
5) В методе enqueue исправить с учётом описания класса:
    while (l.next != null && l.next.prio > prio) --> (l.next != null && l.next.prio < prio)
6) В методе dequeue т.к. head - стражник, следует проверять следующий элемент :
    if (head == null) --> if (head.next == null)
7) В методе dequeue нужно явно объявить какое исключение он бросает:
    public T dequeue() throws Exception --> public T dequeue() throws EmptyQueueException
8) В main неудачно подобраны значения для теста, например можно заменить:
    intQueue.enqueue(5, 1) --> intQueue.enqueue(6, 1)
9) Выход из цикла при ловле исключения - плохое решение как иедалогически, так и функционально. В качестве решения можно реализовать в MyPriorityQueue метод isEmpty()
10) Добавлены javadoc комментарии
11) Стилистические мелочи (пробелы и т.п.)
12) Исправлен testQueueException() нужно было прописать:
    @Test(expected = EmptyQueueException.class)
и убрать try - catch конструкцию и assertEquals
13) Плохие входные значения в testEnqueueDequeueInteger следует использовать разные числа
13) Переменную ret можно сразу инициализировать instance.dequeue()
14) Создавать testEnqueueDequeue... не совсем идеалогически правильно, но простительно